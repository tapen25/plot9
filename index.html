<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Direct Motion BPM</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            margin: 0; overflow: hidden; font-family: 'Courier New', monospace;
            background: #111; color: #fff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh;
        }
        
        #visualizer {
            position: absolute; width: 300px; height: 300px;
            border-radius: 50%; border: 2px solid #fff;
            opacity: 0.5; transform: scale(1);
            transition: transform 0.1s linear, background-color 0.2s;
            z-index: 0;
        }

        .hud { z-index: 10; text-align: center; }
        
        h1 { margin: 0; font-size: 5rem; font-weight: bold; letter-spacing: -2px; }
        p { margin: 10px 0 0; color: #aaa; font-size: 1rem; }
        
        #bpmDisplay { color: #00ff00; text-shadow: 0 0 20px #00ff00; }
        
        #playBtn {
            margin-top: 30px; padding: 15px 40px; font-size: 1.2rem;
            background: #fff; color: #000; border: none; border-radius: 30px;
            cursor: pointer; z-index: 20;
        }
    </style>
</head>
<body>

    <div id="visualizer"></div>

    <div class="hud">
        <h1 id="bpmDisplay">60</h1>
        <p>BPM (Realtime)</p>
        <p style="font-size:0.8rem; margin-top:5px; opacity:0.6;">Shake Device to Accelerate</p>
        <button id="playBtn">START</button>
    </div>

<script>
// ==========================================
// 1. 設定
// ==========================================
const MIN_BPM = 60;   // 静止時のテンポ
const MAX_BPM = 190;  // 激しく振った時の最大テンポ
const SENSITIVITY = 4.0; // 感度（高いほど少しの揺れでMAXになる）

// 状態管理
let isPlaying = false;
let currentActivity = 0; // 0.0 ~ 1.0

// センサー用
const BUFFER_SIZE = 10; // バッファを小さくして反応速度を上げる
const motionBuffer = [];

// ==========================================
// 2. 音源設定 (シンセ & ドラム)
// ==========================================
// 疾走感のあるコード進行 (F#m - D - A - E)
const chords = [
    { note: ["F#3","A3","C#4"], bass: "F#2" },
    { note: ["D3","F#3","A3"],  bass: "D2" },
    { note: ["A3","C#4","E4"],  bass: "A2" },
    { note: ["E3","G#3","B3"],  bass: "E2" }
];

let synth, bass, kick, hat;

function setupAudio() {
    const vol = new Tone.Volume(-4).toDestination();
    const limiter = new Tone.Limiter(-0.2).connect(vol);
    
    // コード用シンセ（歯切れよく）
    synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "sawtooth" },
        envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 },
        volume: -10
    }).connect(limiter);

    // ベース
    bass = new Tone.MonoSynth({
        oscillator: { type: "square" },
        envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 },
        filterEnvelope: { attack: 0.001, decay: 0.2, baseFrequency: 200, octaves: 2.6 },
        volume: -5
    }).connect(limiter);

    // キック（リズムの核）
    kick = new Tone.MembraneSynth({
        pitchDecay: 0.05, octaves: 4, oscillator: { type: "sine" },
        volume: 0
    }).connect(limiter);

    // ハイハット（スピード感を出す）
    hat = new Tone.MetalSynth({
        frequency: 200, envelope: { attack: 0.001, decay: 0.05, release: 0.01 },
        harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5,
        volume: -15
    }).connect(limiter);
}

// ==========================================
// 3. ループ処理 (音の生成)
// ==========================================
function startLoop() {
    let step = 0;

    Tone.Transport.scheduleRepeat((time) => {
        // 16分音符ごとの処理
        const beat = step % 16;
        const barStep = Math.floor(step / 16) % 4; // 4小節ループ
        const currentChord = chords[barStep];

        // --- 1. キック (4つ打ち: ドン・ドン・ドン・ドン) ---
        if (beat % 4 === 0) {
            kick.triggerAttackRelease("C1", "8n", time);
            
            // ビジュアル同期（キックの瞬間に円が光る）
            pulseVisual();
        }

        // --- 2. ハイハット (裏拍でチッ・チッ) ---
        if (beat % 2 !== 0) {
            hat.triggerAttackRelease("32n", time);
        }

        // --- 3. コード (裏打ちで刻む: ズッ・チャ・ズッ・チャ) ---
        if (beat % 4 === 2) {
            synth.triggerAttackRelease(currentChord.note, "16n", time);
        }

        // --- 4. ベース (16分で走らせる) ---
        // パターン: ドッ・ドッ・ドッ・ドッ
        if (beat % 2 === 0) {
            bass.triggerAttackRelease(currentChord.bass, "16n", time);
        }

        step++;
    }, "16n");

    Tone.Transport.start();
}

// ビジュアル演出
function pulseVisual() {
    const v = document.getElementById('visualizer');
    v.style.transform = `scale(${1.2 + (currentActivity * 0.5)})`;
    v.style.backgroundColor = `hsl(${120 + (currentActivity * 240)}, 100%, 50%)`; // 緑 -> 赤
    setTimeout(() => {
        v.style.transform = 'scale(1)';
        v.style.backgroundColor = 'transparent';
    }, 100);
}

// ==========================================
// 4. メインループ (BPM制御 & センサー)
// ==========================================
function update() {
    requestAnimationFrame(update);
    if (!isPlaying) return;

    // A. センサー値の平均を取る（ノイズ除去）
    let raw = 0;
    if (motionBuffer.length > 0) {
        // 直近の平均値を取得
        raw = motionBuffer.reduce((a, b) => a + b, 0) / motionBuffer.length;
    }
    
    // B. 感度適用 (0.0 ~ 1.0に正規化)
    // SENSITIVITY倍して、1.0でキャップする
    let targetAct = Math.min(raw * SENSITIVITY, 1.0);

    // C. スムージング (急激すぎる変化を少し和らげるが、反応は早く)
    // 0.2 くらいの係数だと「ヌルっ」と追従する感じになる
    currentActivity += (targetAct - currentActivity) * 0.15;

    // D. BPMへの変換
    // 最小60 + (進捗 * 幅)
    const targetBPM = MIN_BPM + (currentActivity * (MAX_BPM - MIN_BPM));
    
    // E. Tone.jsへの適用 (rampToで0.1秒かけて変化させる＝ほぼリアルタイム)
    Tone.Transport.bpm.rampTo(targetBPM, 0.1);

    // F. UI更新
    const bpmInt = Math.round(Tone.Transport.bpm.value);
    const bpmDisp = document.getElementById('bpmDisplay');
    bpmDisp.innerText = bpmInt;
    
    // 色を変える (遅い=緑, 速い=赤)
    // HSL: 120(緑) -> 0(赤)
    const hue = 120 - (currentActivity * 120);
    bpmDisp.style.color = `hsl(${hue}, 100%, 60%)`;
    bpmDisp.style.textShadow = `0 0 20px hsl(${hue}, 100%, 60%)`;
}

// ==========================================
// 5. イベントハンドラ
// ==========================================
function handleMotion(event) {
    const acc = event.accelerationIncludingGravity;
    if (!acc) return;

    // 重力成分を除去したいが、簡易的に変化量を見る
    // ハイパスフィルタ的な処理（前回の値との差分）の方が
    // 「振った」動作だけを取りやすいが、ここでは絶対値の変動を見る簡易版
    
    // X, Y, Z の合成ベクトル
    // ※ 重力(約9.8)が常にかかるため、それとの差分を簡易計算
    // 本来は devicemotion の acceleration (重力抜き) を使うのがベストだが
    // Android/iOS互換性のため IncludingGravity を使い、
    // 「9.8からのズレ」や「分散」を見ると良い。
    // 今回は「バッファ内の標準偏差」を使うと"揺れ"だけ抽出できる。
    
    const x = acc.x || 0;
    const y = acc.y || 0;
    const z = acc.z || 0;
    const mag = Math.sqrt(x*x + y*y + z*z);
    
    motionBuffer.push(mag);
    if(motionBuffer.length > BUFFER_SIZE) motionBuffer.shift();
}

// 標準偏差計算（静止時は0に近くなる）
function getActivityFromBuffer() {
    if (motionBuffer.length < 2) return 0;
    const mean = motionBuffer.reduce((a,b)=>a+b,0) / motionBuffer.length;
    const variance = motionBuffer.reduce((a,b)=>a+(b-mean)**2, 0) / motionBuffer.length;
    return Math.sqrt(variance); 
}

// ループ処理の上書き（標準偏差版）
function update() {
    requestAnimationFrame(update);
    if (!isPlaying) return;

    // 標準偏差 = 「どれだけ激しく振られているか」
    const sd = getActivityFromBuffer();
    
    // 感度調整
    let targetAct = Math.min(sd / 5.0, 1.0); // 5.0m/s^2 くらいの揺れでMAX

    // 値を滑らかにする
    currentActivity += (targetAct - currentActivity) * 0.1;

    // BPM計算
    const targetBPM = MIN_BPM + (currentActivity * (MAX_BPM - MIN_BPM));
    Tone.Transport.bpm.rampTo(targetBPM, 0.1);

    // UI
    const bpmDisp = document.getElementById('bpmDisplay');
    const bpmInt = Math.round(Tone.Transport.bpm.value);
    bpmDisp.innerText = bpmInt;
    
    const hue = 120 - (currentActivity * 120);
    bpmDisp.style.color = `hsl(${hue}, 100%, 60%)`;
    bpmDisp.style.textShadow = `0 0 30px hsl(${hue}, 100%, 40%)`;
}


// 開始ボタン
document.getElementById('playBtn').addEventListener('click', async () => {
    // iOS Permission
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        const p = await DeviceMotionEvent.requestPermission();
        if(p !== 'granted') return alert('モーションセンサーを許可してください');
    }

    window.addEventListener('devicemotion', handleMotion);
    await Tone.start();
    setupAudio();
    startLoop();
    isPlaying = true;
    document.getElementById('playBtn').style.display = 'none';
    
    // アニメーションループ開始
    update();
});

// デバッグ用: 画面タップ連打で加速
document.addEventListener('mousedown', () => {
    if(isPlaying) {
        // 無理やりバッファに大きな値を入れて揺れを偽装
        for(let i=0; i<5; i++) motionBuffer.push(10 + Math.random()*10);
    }
});
</script>
</body>
</html>